<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>dubboSPI详解 | 心无迷惘</title>
  <meta name="keywords" content=" SPI ">
  <meta name="description" content="dubboSPI详解 | 心无迷惘">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="11月的最后一天，即时结束又是开始。希望我们都能够努力学习，坚持不懈的去追逐自己的梦想。古之立大事者，不惟有超世之才，亦必有坚忍不拔之志 心存迷惘 则无法继续前行😃😃😃😃😃😃😃😃😃😃😃😃🧐🧐🧐🧐🧐🧐🧐🧐🧐💪💪💪💪💪💪">
<meta property="og:type" content="website">
<meta property="og:title" content="关于">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;about&#x2F;index.html">
<meta property="og:site_name" content="心无迷惘">
<meta property="og:description" content="11月的最后一天，即时结束又是开始。希望我们都能够努力学习，坚持不懈的去追逐自己的梦想。古之立大事者，不惟有超世之才，亦必有坚忍不拔之志 心存迷惘 则无法继续前行😃😃😃😃😃😃😃😃😃😃😃😃🧐🧐🧐🧐🧐🧐🧐🧐🧐💪💪💪💪💪💪">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-02-15T13:29:23.087Z">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>Ocean Bai</span>
</div>

<div class="icon">
    
        
    
        
        <a title="github" href="https://github.com/oceanbai" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(30)</small></div></li>
    
        
            
            <li><div data-rel="dubbo">dubbo<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="java基础">java基础<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="设计模式">设计模式<small>(6)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="面试">面试<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="设计原则">设计原则<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="JDK">JDK<small>(2)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="30">
<input type="hidden" id="yelog_site_word_count" value="110.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color5">动态代理</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">SPI</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">面试</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">垃圾</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">类加载器</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">缓存</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">算法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">反射</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">设计模式</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">工厂模式</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">总结面试</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">设计原则</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">jdk</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">线程池</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="JDK "
           href="/2020/02/19/java/JDK/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="jdk"
           data-author="" >
            <span class="post-title" title="ThreadLocal源码解析">ThreadLocal源码解析</span>
            <span class="post-date" title="2020-02-19 09:41:31">2020/02/19</span>
        </a>
        
        <a  class="面试 "
           href="/2020/02/18/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E6%A0%88/"
           data-tag="面试,总结面试"
           data-author="" >
            <span class="post-title" title="面试技术栈">面试技术栈</span>
            <span class="post-date" title="2020-02-18 16:41:32">2020/02/18</span>
        </a>
        
        <a  class="dubbo "
           href="/2020/02/17/dubbo/dubboSPI/"
           data-tag="SPI"
           data-author="" >
            <span class="post-title" title="dubboSPI详解">dubboSPI详解</span>
            <span class="post-date" title="2020-02-17 14:41:31">2020/02/17</span>
        </a>
        
        <a  class="面试 "
           href="/2020/02/17/%E9%9D%A2%E8%AF%95/%E7%BE%8E%E5%9B%A2%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AE%9E%E4%B9%A0%E7%94%9F/"
           data-tag="面试"
           data-author="" >
            <span class="post-title" title="美团研究生实习生">美团研究生实习生</span>
            <span class="post-date" title="2020-02-17 11:41:31">2020/02/17</span>
        </a>
        
        <a  class=""
           href="/2020/02/17/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="算法/基本排序算法">算法/基本排序算法</span>
            <span class="post-date" title="2020-02-17 10:46:52">2020/02/17</span>
        </a>
        
        <a  class="设计模式 "
           href="/2020/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="桥接模式----处理多维变化----五">桥接模式----处理多维变化----五</span>
            <span class="post-date" title="2020-02-15 21:42:31">2020/02/15</span>
        </a>
        
        <a  class="设计模式 "
           href="/2020/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="适配器模式----不兼容结构的协调----六">适配器模式----不兼容结构的协调----六</span>
            <span class="post-date" title="2020-02-15 21:42:31">2020/02/15</span>
        </a>
        
        <a  class="面试 "
           href="/2020/02/15/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag="面试"
           data-author="" >
            <span class="post-title" title="面试题">面试题</span>
            <span class="post-date" title="2020-02-15 21:41:32">2020/02/15</span>
        </a>
        
        <a  class="设计模式 "
           href="/2020/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="模板方法模式--------四">模板方法模式--------四</span>
            <span class="post-date" title="2020-02-14 16:38:31">2020/02/14</span>
        </a>
        
        <a  class="设计模式 "
           href="/2020/02/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式,工厂模式"
           data-author="" >
            <span class="post-title" title="抽象工厂模式--------三">抽象工厂模式--------三</span>
            <span class="post-date" title="2020-02-13 21:41:31">2020/02/13</span>
        </a>
        
        <a  class="java基础 "
           href="/2020/02/12/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8(ClassLoader)/"
           data-tag="类加载器"
           data-author="" >
            <span class="post-title" title="深入理解java类加载器(ClassLoader)">深入理解java类加载器(ClassLoader)</span>
            <span class="post-date" title="2020-02-12 21:41:31">2020/02/12</span>
        </a>
        
        <a  class="java基础 "
           href="/2020/02/12/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF(Class%E5%AF%B9%E8%B1%A1)%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"
           data-tag="反射"
           data-author="" >
            <span class="post-title" title="深入理解Java类型信息(Class对象)与反射机制">深入理解Java类型信息(Class对象)与反射机制</span>
            <span class="post-date" title="2020-02-12 21:41:31">2020/02/12</span>
        </a>
        
        <a  class="算法 "
           href="/2020/02/12/%E7%AE%97%E6%B3%95/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95------FIFO%20%E3%80%81LRU%E3%80%81LFU/"
           data-tag="缓存"
           data-author="" >
            <span class="post-title" title="缓存算法（FIFO、LRU、LFU）">缓存算法（FIFO、LRU、LFU）</span>
            <span class="post-date" title="2020-02-12 10:22:00">2020/02/12</span>
        </a>
        
        <a  class="算法 "
           href="/2020/02/12/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%96%87%E6%95%B0/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="回文数">回文数</span>
            <span class="post-date" title="2020-02-12 10:22:00">2020/02/12</span>
        </a>
        
        <a  class="算法 "
           href="/2020/02/12/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%9803-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="面试题03-数组中重复的数字">面试题03-数组中重复的数字</span>
            <span class="post-date" title="2020-02-12 10:22:00">2020/02/12</span>
        </a>
        
        <a  class="设计模式 "
           href="/2020/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式,工厂模式"
           data-author="" >
            <span class="post-title" title="工厂方法模式--------二">工厂方法模式--------二</span>
            <span class="post-date" title="2020-02-12 10:22:00">2020/02/12</span>
        </a>
        
        <a  class="dubbo "
           href="/2020/02/11/dubbo/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20RPC%20%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%AF%87/"
           data-tag="动态代理"
           data-author="" >
            <span class="post-title" title="深入理解 RPC 之动态代理篇">深入理解 RPC 之动态代理篇</span>
            <span class="post-date" title="2020-02-11 21:41:31">2020/02/11</span>
        </a>
        
        <a  class="dubbo "
           href="/2020/02/11/dubbo/dubbo%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag="面试"
           data-author="" >
            <span class="post-title" title="dubbo面试题">dubbo面试题</span>
            <span class="post-date" title="2020-02-11 21:41:31">2020/02/11</span>
        </a>
        
        <a  class="java基础 "
           href="/2020/02/11/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"
           data-tag="垃圾"
           data-author="" >
            <span class="post-title" title="垃圾回收">垃圾回收</span>
            <span class="post-date" title="2020-02-11 21:41:31">2020/02/11</span>
        </a>
        
        <a  class="设计模式 "
           href="/2020/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式,工厂模式"
           data-author="" >
            <span class="post-title" title="简单工厂模式--------一">简单工厂模式--------一</span>
            <span class="post-date" title="2020-02-11 21:41:31">2020/02/11</span>
        </a>
        
        <a  class="JDK "
           href="/2020/02/11/java/JDK/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90/"
           data-tag="线程池"
           data-author="" >
            <span class="post-title" title="线程池源码解析">线程池源码解析</span>
            <span class="post-date" title="2020-02-11 21:41:31">2020/02/11</span>
        </a>
        
        <a  class="算法 "
           href="/2019/11/30/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E5%A0%86/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="二叉堆">二叉堆</span>
            <span class="post-date" title="2019-11-30 21:49:13">2019/11/30</span>
        </a>
        
        <a  class="面试 "
           href="/2019/11/30/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E8%A6%81%E6%B1%82/"
           data-tag="面试"
           data-author="" >
            <span class="post-title" title="别人面试要求">别人面试要求</span>
            <span class="post-date" title="2019-11-30 21:41:31">2019/11/30</span>
        </a>
        
        <a  class="设计原则 "
           href="/2019/05/26/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"
           data-tag="设计原则"
           data-author="" >
            <span class="post-title" title="第二原则:依赖倒置原则">第二原则:依赖倒置原则</span>
            <span class="post-date" title="2019-05-26 17:07:00">2019/05/26</span>
        </a>
        
        <a  class="设计原则 "
           href="/2019/05/26/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"
           data-tag="设计原则"
           data-author="" >
            <span class="post-title" title="第一原则:开闭原则">第一原则:开闭原则</span>
            <span class="post-date" title="2019-05-26 17:07:00">2019/05/26</span>
        </a>
        
        <a  class="设计原则 "
           href="/2019/05/26/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/"
           data-tag="设计原则"
           data-author="" >
            <span class="post-title" title="第七原则:合成复用原则">第七原则:合成复用原则</span>
            <span class="post-date" title="2019-05-26 17:07:00">2019/05/26</span>
        </a>
        
        <a  class="设计原则 "
           href="/2019/05/26/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"
           data-tag="设计原则"
           data-author="" >
            <span class="post-title" title="第五原则:迪米特法则">第五原则:迪米特法则</span>
            <span class="post-date" title="2019-05-26 17:07:00">2019/05/26</span>
        </a>
        
        <a  class="设计原则 "
           href="/2019/05/26/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"
           data-tag="设计原则"
           data-author="" >
            <span class="post-title" title="第三原则:单一职责原则">第三原则:单一职责原则</span>
            <span class="post-date" title="2019-05-26 17:07:00">2019/05/26</span>
        </a>
        
        <a  class="设计原则 "
           href="/2019/05/26/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"
           data-tag="设计原则"
           data-author="" >
            <span class="post-title" title="第四原则:接口隔离原则">第四原则:接口隔离原则</span>
            <span class="post-date" title="2019-05-26 17:07:00">2019/05/26</span>
        </a>
        
        <a  class="设计原则 "
           href="/2019/05/26/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"
           data-tag="设计原则"
           data-author="" >
            <span class="post-title" title="第六原则:里氏替换原则">第六原则:里氏替换原则</span>
            <span class="post-date" title="2019-05-26 17:07:00">2019/05/26</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-dubbo/dubboSPI" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">dubboSPI详解</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="dubbo">dubbo</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color4">SPI</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-02-17 17:15:07'>2020-02-17 14:41</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:7.6k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#拓展机制-SPI"><span class="toc-text">拓展机制 SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-概述"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-改进"><span class="toc-text">2. 改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代码结构"><span class="toc-text">3. 代码结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ExtensionLoader"><span class="toc-text">4. ExtensionLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-属性"><span class="toc-text">4.1 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-获得拓展配置"><span class="toc-text">4.2 获得拓展配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-getExtensionClasses"><span class="toc-text">4.2.1 getExtensionClasses</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-loadExtensionClasses"><span class="toc-text">4.2.2 loadExtensionClasses</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-loadFile"><span class="toc-text">4.2.3 loadFile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-其他方法"><span class="toc-text">4.2.4 其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-获得拓展加载器"><span class="toc-text">4.3 获得拓展加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-getExtensionLoader"><span class="toc-text">4.3.1 getExtensionLoader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-构造方法"><span class="toc-text">4.3.2 构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-获得指定拓展对象"><span class="toc-text">4.4 获得指定拓展对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-getExtension"><span class="toc-text">4.4.1 getExtension</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-createExtension"><span class="toc-text">4.4.2 createExtension</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-injectExtension"><span class="toc-text">4.4.3 injectExtension</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-其他方法"><span class="toc-text">4.4.4 其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-获得自适应的拓展对象"><span class="toc-text">4.5 获得自适应的拓展对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-getAdaptiveExtension"><span class="toc-text">4.5.1 getAdaptiveExtension</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-createAdaptiveExtension"><span class="toc-text">4.5.2 createAdaptiveExtension</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-getAdaptiveExtensionClass"><span class="toc-text">4.5.3 getAdaptiveExtensionClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-4-createAdaptiveExtensionClassCode"><span class="toc-text">4.5.4 createAdaptiveExtensionClassCode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-获得激活的拓展对象数组"><span class="toc-text">4.6 获得激活的拓展对象数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-getExtensionLoader"><span class="toc-text">4.6.1 getExtensionLoader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-ActivateComparator"><span class="toc-text">4.6.2 ActivateComparator</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="拓展机制-SPI"><a href="#拓展机制-SPI" class="headerlink" title="拓展机制 SPI"></a>拓展机制 SPI</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>本文主要分享 <strong>Dubbo 的拓展机制 SPI</strong>。</p>
<p>想要理解 Dubbo ，理解 Dubbo SPI 是非常必须的。在 Dubbo 中，提供了大量的<strong>拓展点</strong>，基于 Dubbo SPI 机制加载。如下图所示：</p>
<p><img src="/Users/ocean/Downloads/01.png" alt="Dubbo 拓展点"></p>
<h2 id="2-改进"><a href="#2-改进" class="headerlink" title="2. 改进"></a>2. 改进</h2><p>为何Dubbo要自己实现SPI</p>
<blockquote>
<p>FROM <a href="http://dubbo.apache.org/zh-cn/docs/dev/SPI.html" target="_blank" rel="noopener">《Dubbo 开发指南 —— 拓展点加载》</a></p>
<p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。</p>
<p>Dubbo 改进了 JDK 标准的 SPI 的以下问题：</p>
<ol>
<li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</li>
<li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。</li>
<li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>
</ol>
</blockquote>
<ul>
<li>Dubbo 自己实现了一套 SPI 机制，而不是使用 Java 标准的 SPI 。</li>
<li>第一点问题，Dubbo 有很多的拓展点，例如 Protocol、Filter 等等。并且每个拓展点有多种的实现，例如 Protocol 有 DubboProtocol、InjvmProtocol、RestProtocol 等等。那么使用 JDK SPI 机制，会初始化无用的拓展点及其实现，造成不必要的耗时与资源浪费。<ul>
<li>如果无法理解的胖友，跟着 <a href="http://blog.csdn.net/top_code/article/details/51934459" target="_blank" rel="noopener">《Java SPI(Service Provider Interface)简介》</a> 文章，<strong>写多个拓展实现</strong>，就很容易理解了。</li>
</ul>
</li>
<li>第二点问题，扩展点加载失败的时候暴露出的问题并不是真正失败的原因。</li>
<li>第三点问题，严格来说，这不算问题，<strong>而是增加了功能特性</strong>，在下文我们会看到。</li>
</ul>
<h2 id="3-代码结构"><a href="#3-代码结构" class="headerlink" title="3. 代码结构"></a>3. 代码结构</h2><p>Dubbo SPI 在 <code>dubbo-common</code> 的 <a href="https://github.com/YunaiV/dubbo/tree/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension" target="_blank" rel="noopener"><code>extension</code></a> 包实现，如下图所示：</p>
<p><img src="/Users/ocean/Downloads/02.png" alt="代码结构"></p>
<h2 id="4-ExtensionLoader"><a href="#4-ExtensionLoader" class="headerlink" title="4. ExtensionLoader"></a>4. ExtensionLoader</h2><p><a href="http://svip.iocoder.cn/Dubbo/spi/ExtensionLoader" target="_blank" rel="noopener"><code>com.alibaba.dubbo.common.extension.ExtensionLoader</code></a> ，拓展加载器。这是 Dubbo SPI 的<strong>核心</strong>。</p>
<h3 id="4-1-属性"><a href="#4-1-属性" class="headerlink" title="4.1 属性"></a>4.1 属性</h3><pre><code class="java">1: private static final String SERVICES_DIRECTORY = &quot;META-INF/services/&quot;;
  2: 
  3: private static final String DUBBO_DIRECTORY = &quot;META-INF/dubbo/&quot;;
  4: 
  5: private static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + &quot;internal/&quot;;
  6: 
  7: private static final Pattern NAME_SEPARATOR = Pattern.compile(&quot;\\s*[,]+\\s*&quot;);
  8: 
  9: // ============================== 静态属性 ==============================
 10: 
 11: /**
 12:  * 拓展加载器集合
 13:  *
 14:  * key：拓展接口
 15:  */
 16: private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();
 17: /**
 18:  * 拓展实现类集合
 19:  *
 20:  * key：拓展实现类
 21:  * value：拓展对象。
 22:  *
 23:  * 例如，key 为 Class&lt;AccessLogFilter&gt;
 24:  *  value 为 AccessLogFilter 对象
 25:  */
 26: private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();
 27: 
 28: // ============================== 对象属性 ==============================
 29: 
 30: /**
 31:  * 拓展接口。
 32:  * 例如，Protocol
 33:  */
 34: private final Class&lt;?&gt; type;
 35: /**
 36:  * 对象工厂
 37:  *
 38:  * 用于调用 {@link #injectExtension(Object)} 方法，向拓展对象注入依赖属性。
 39:  *
 40:  * 例如，StubProxyFactoryWrapper 中有 `Protocol protocol` 属性。
 41:  */
 42: private final ExtensionFactory objectFactory;
 43: /**
 44:  * 缓存的拓展名与拓展类的映射。
 45:  *
 46:  * 和 {@link #cachedClasses} 的 KV 对调。
 47:  *
 48:  * 通过 {@link #loadExtensionClasses} 加载
 49:  */
 50: private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = new ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();
 51: /**
 52:  * 缓存的拓展实现类集合。
 53:  *
 54:  * 不包含如下两种类型：
 55:  *  1. 自适应拓展实现类。例如 AdaptiveExtensionFactory
 56:  *  2. 带唯一参数为拓展接口的构造方法的实现类，或者说拓展 Wrapper 实现类。例如，ProtocolFilterWrapper 。
 57:  *   拓展 Wrapper 实现类，会添加到 {@link #cachedWrapperClasses} 中
 58:  *
 59:  * 通过 {@link #loadExtensionClasses} 加载
 60:  */
 61: private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = new Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();
 62: 
 63: /**
 64:  * 拓展名与 @Activate 的映射
 65:  *
 66:  * 例如，AccessLogFilter。
 67:  *
 68:  * 用于 {@link #getActivateExtension(URL, String)}
 69:  */
 70: private final Map&lt;String, Activate&gt; cachedActivates = new ConcurrentHashMap&lt;String, Activate&gt;();
 71: /**
 72:  * 缓存的拓展对象集合
 73:  *
 74:  * key：拓展名
 75:  * value：拓展对象
 76:  *
 77:  * 例如，Protocol 拓展
 78:  *      key：dubbo value：DubboProtocol
 79:  *      key：injvm value：InjvmProtocol
 80:  *
 81:  * 通过 {@link #loadExtensionClasses} 加载
 82:  */
 83: private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();
 84: /**
 85:  * 缓存的自适应( Adaptive )拓展对象
 86:  */
 87: private final Holder&lt;Object&gt; cachedAdaptiveInstance = new Holder&lt;Object&gt;();
 88: /**
 89:  * 缓存的自适应拓展对象的类
 90:  *
 91:  * {@link #getAdaptiveExtensionClass()}
 92:  */
 93: private volatile Class&lt;?&gt; cachedAdaptiveClass = null;
 94: /**
 95:  * 缓存的默认拓展名
 96:  *
 97:  * 通过 {@link SPI} 注解获得
 98:  */
 99: private String cachedDefaultName;
100: /**
101:  * 创建 {@link #cachedAdaptiveInstance} 时发生的异常。
102:  *
103:  * 发生异常后，不再创建，参见 {@link #createAdaptiveExtension()}
104:  */
105: private volatile Throwable createAdaptiveInstanceError;
106: 
107: /**
108:  * 拓展 Wrapper 实现类集合
109:  *
110:  * 带唯一参数为拓展接口的构造方法的实现类
111:  *
112:  * 通过 {@link #loadExtensionClasses} 加载
113:  */
114: private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;
115: 
116: /**
117:  * 拓展名 与 加载对应拓展类发生的异常 的 映射
118:  *
119:  * key：拓展名
120:  * value：异常
121:  *
122:  * 在 {@link #loadFile(Map, String)} 时，记录
123:  */
124: private Map&lt;String, IllegalStateException&gt; exceptions = new ConcurrentHashMap&lt;String, IllegalStateException&gt;();</code></pre>
<ul>
<li><p>第 1 至 5 行：在 <code>META-INF/dubbo/internal/</code> 和 <code>META-INF/dubbo/</code> 目录下，放置 <strong>接口全限定名</strong> 配置文件，<strong>每行</strong>内容为：<strong>拓展名=拓展实现类全限定名</strong>。</p>
<ul>
<li><p><code>META-INF/dubbo/internal/</code> 目录下，从名字上可以看出，用于 Dubbo <strong>内部</strong>提供的拓展实现。下图是一个例子：<img src="/Users/ocean/Downloads/03.png" alt="META-INF/dubbo/internal/ 例子"></p>
</li>
<li><p><code>META-INF/dubbo/</code> 目录下，用于用户<strong>自定义</strong>的拓展实现。</p>
</li>
<li><p><code>META-INF/service/</code> 目录下，Java SPI 的配置目录。在 <a href="http://svip.iocoder.cn/Dubbo/spi/#" target="_blank" rel="noopener">「4.2 加载拓展配置」</a> 中，我们会看到 Dubbo SPI 对 Java SPI 做了<strong>兼容</strong>。</p>
</li>
</ul>
</li>
<li><p>第 7 行：<code>NAME_SEPARATOR</code> ，拓展名分隔符，使用<strong>逗号</strong>。</p>
</li>
<li><p><strong>第 9 至 124 行</strong>，我们将属性分成了两类：1）静态属性；2）对象属性。这是为啥呢？</p>
</li>
<li><p>【静态属性】一方面，ExtensionLoader 是 ExtensionLoader 的<strong>管理容器</strong>。一个拓展( 拓展接口 )对应一个 ExtensionLoader 对象。例如，Protocol 和 Filter <strong>分别</strong>对应一个 ExtensionLoader 对象。</p>
</li>
<li><p>【对象属性】另一方面，一个拓展通过其 ExtensionLoader 对象，加载它的<strong>拓展实现们</strong>。我们会发现多个属性都是 “<strong>cached</strong>“ 开头。ExtensionLoader 考虑到性能和资源的优化，读取拓展配置后，会首先进行<strong>缓存</strong>。等到 Dubbo 代码<strong>真正</strong>用到对应的拓展实现时，进行拓展实现的对象的初始化。并且，初始化完成后，也会进行<strong>缓存</strong>。</p>
<p>也就是说：</p>
<ul>
<li>缓存加载的拓展配置</li>
<li>缓存创建的拓展实现对象</li>
</ul>
</li>
</ul>
<h3 id="4-2-获得拓展配置"><a href="#4-2-获得拓展配置" class="headerlink" title="4.2 获得拓展配置"></a>4.2 获得拓展配置</h3><h4 id="4-2-1-getExtensionClasses"><a href="#4-2-1-getExtensionClasses" class="headerlink" title="4.2.1 getExtensionClasses"></a>4.2.1 getExtensionClasses</h4><p><code>#getExtensionClasses()</code> 方法，获得拓展实现类数组。</p>
<pre><code class="java">private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = new Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();

private volatile Class&lt;?&gt; cachedAdaptiveClass = null;

private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;

  1: /**
  2:  * 获得拓展实现类数组
  3:  *
  4:  * @return 拓展实现类数组
  5:  */
  6: private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {
  7:     // 从缓存中，获得拓展实现类数组
  8:     Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();
  9:     if (classes == null) {
 10:         synchronized (cachedClasses) {
 11:             classes = cachedClasses.get();
 12:             if (classes == null) {
 13:                 // 从配置文件中，加载拓展实现类数组
 14:                 classes = loadExtensionClasses();
 15:                 // 设置到缓存中
 16:                 cachedClasses.set(classes);
 17:             }
 18:         }
 19:     }
 20:     return classes;
 21: }</code></pre>
<ul>
<li><p><code>cachedClasses</code> 属性，缓存的拓展实现类集合。它不包含如下两种类型的拓展实现：</p>
<ul>
<li><p><strong>自适应</strong>拓展实现类。例如 AdaptiveExtensionFactory 。</p>
<ul>
<li>拓展 Adaptive 实现类，会添加到 <code>cachedAdaptiveClass</code> 属性中。</li>
</ul>
</li>
<li><p>带<strong>唯一参数为拓展接口</strong>的构造方法的实现类，或者说拓展 Wrapper 实现类。例如  ProtocolFilterWrapper 。</p>
<ul>
<li>拓展 Wrapper 实现类，会添加到 <code>cachedWrapperClasses</code> 属性中。</li>
</ul>
</li>
<li><p>总结来说，<code>cachedClasses</code> + <code>cachedAdaptiveClass</code> + <code>cachedWrapperClasses</code> 才是<strong>完整</strong>缓存的拓展实现类的配置。</p>
</li>
</ul>
</li>
<li><p>第 7 至 11 行：从缓存中，获得拓展实现类数组。</p>
</li>
<li><p>第 12 至 14 行：当缓存不存在时，调用 <code>#loadExtensionClasses()</code> 方法，从配置文件中，加载拓展实现类数组。</p>
</li>
<li><p>第 16 行：设置加载的实现类数组，到缓存中。</p>
</li>
</ul>
<h4 id="4-2-2-loadExtensionClasses"><a href="#4-2-2-loadExtensionClasses" class="headerlink" title="4.2.2 loadExtensionClasses"></a>4.2.2 loadExtensionClasses</h4><p><code>#loadExtensionClasses()</code> 方法，从<strong>多个</strong>配置文件中，加载拓展实现类数组。</p>
<pre><code class="java">1: /**
 2:  * 加载拓展实现类数组
 3:  *
 4:  * 无需声明 synchronized ，因为唯一调用该方法的 {@link #getExtensionClasses()} 已经声明。
 5:  * // synchronized in getExtensionClasses
 6:  *
 7:  * @return 拓展实现类数组
 8:  */
 9: private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {
10:     // 通过 @SPI 注解，获得默认的拓展实现类名
11:     final SPI defaultAnnotation = type.getAnnotation(SPI.class);
12:     if (defaultAnnotation != null) {
13:         String value = defaultAnnotation.value();
14:         if ((value = value.trim()).length() &gt; 0) {
15:             String[] names = NAME_SEPARATOR.split(value);
16:             if (names.length &gt; 1) {
17:                 throw new IllegalStateException(&quot;more than 1 default extension name on extension &quot; + type.getName()
18:                         + &quot;: &quot; + Arrays.toString(names));
19:             }
20:             if (names.length == 1) cachedDefaultName = names[0];
21:         }
22:     }
23: 
24:     // 从配置文件中，加载拓展实现类数组
25:     Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;String, Class&lt;?&gt;&gt;();
26:     loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);
27:     loadFile(extensionClasses, DUBBO_DIRECTORY);
28:     loadFile(extensionClasses, SERVICES_DIRECTORY);
29:     return extensionClasses;
30: }</code></pre>
<ul>
<li>第 10 至 22 行：通过 <code>@SPI</code> 注解，获得拓展接口对应的<strong>默认的</strong>拓展实现类名。在 <a href="http://svip.iocoder.cn/Dubbo/spi/#" target="_blank" rel="noopener">「5. @SPI」</a> 详细解析。</li>
<li>第 25 至 29 行：调用 <code>#loadFile(extensionClasses, dir)</code> 方法，从配置文件中，加载拓展实现类数组。<strong>注意</strong>，此处配置文件的加载顺序。</li>
</ul>
<h4 id="4-2-3-loadFile"><a href="#4-2-3-loadFile" class="headerlink" title="4.2.3 loadFile"></a>4.2.3 loadFile</h4><p><code>#loadFile(extensionClasses, dir)</code> 方法，从<strong>一个</strong>配置文件中，加载拓展实现类数组。代码如下：</p>
<pre><code class="java">/**
 * 缓存的自适应拓展对象的类
 *
 * {@link #getAdaptiveExtensionClass()}
 */
private volatile Class&lt;?&gt; cachedAdaptiveClass = null;

/**
 * 拓展 Wrapper 实现类集合
 *
 * 带唯一参数为拓展接口的构造方法的实现类
 *
 * 通过 {@link #loadExtensionClasses} 加载
 */
private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;

/**
 * 拓展名与 @Activate 的映射
 *
 * 例如，AccessLogFilter。
 *
 * 用于 {@link #getActivateExtension(URL, String)}
 */
private final Map&lt;String, Activate&gt; cachedActivates = new ConcurrentHashMap&lt;String, Activate&gt;();

/**
 * 缓存的拓展名与拓展类的映射。
 *
 * 和 {@link #cachedClasses} 的 KV 对调。
 *
 * 通过 {@link #loadExtensionClasses} 加载
 */
private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = new ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();

/**
 * 拓展名 与 加载对应拓展类发生的异常 的 映射
 *
 * key：拓展名
 * value：异常
 *
 * 在 {@link #loadFile(Map, String)} 时，记录
 */
private Map&lt;String, IllegalStateException&gt; exceptions = new ConcurrentHashMap&lt;String, IllegalStateException&gt;();

  1: /**
  2:  * 从一个配置文件中，加载拓展实现类数组。
  3:  *
  4:  * @param extensionClasses 拓展类名数组
  5:  * @param dir 文件名
  6:  */
  7: private void loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir) {
  8:     // 完整的文件名
  9:     String fileName = dir + type.getName();
 10:     try {
 11:         Enumeration&lt;java.net.URL&gt; urls;
 12:         // 获得文件名对应的所有文件数组
 13:         ClassLoader classLoader = findClassLoader();
 14:         if (classLoader != null) {
 15:             urls = classLoader.getResources(fileName);
 16:         } else {
 17:             urls = ClassLoader.getSystemResources(fileName);
 18:         }
 19:         // 遍历文件数组
 20:         if (urls != null) {
 21:             while (urls.hasMoreElements()) {
 22:                 java.net.URL url = urls.nextElement();
 23:                 try {
 24:                     BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), &quot;utf-8&quot;));
 25:                     try {
 26:                         String line;
 27:                         while ((line = reader.readLine()) != null) {
 28:                             // 跳过当前被注释掉的情况，例如 #spring=xxxxxxxxx
 29:                             final int ci = line.indexOf(&#39;#&#39;);
 30:                             if (ci &gt;= 0) line = line.substring(0, ci);
 31:                             line = line.trim();
 32:                             if (line.length() &gt; 0) {
 33:                                 try {
 34:                                     // 拆分，key=value 的配置格式
 35:                                     String name = null;
 36:                                     int i = line.indexOf(&#39;=&#39;);
 37:                                     if (i &gt; 0) {
 38:                                         name = line.substring(0, i).trim();
 39:                                         line = line.substring(i + 1).trim();
 40:                                     }
 41:                                     if (line.length() &gt; 0) {
 42:                                         // 判断拓展实现，是否实现拓展接口
 43:                                         Class&lt;?&gt; clazz = Class.forName(line, true, classLoader);
 44:                                         if (!type.isAssignableFrom(clazz)) {
 45:                                             throw new IllegalStateException(&quot;Error when load extension class(interface: &quot; +
 46:                                                     type + &quot;, class line: &quot; + clazz.getName() + &quot;), class &quot;
 47:                                                     + clazz.getName() + &quot;is not subtype of interface.&quot;);
 48:                                         }
 49:                                         // 缓存自适应拓展对象的类到 `cachedAdaptiveClass`
 50:                                         if (clazz.isAnnotationPresent(Adaptive.class)) {
 51:                                             if (cachedAdaptiveClass == null) {
 52:                                                 cachedAdaptiveClass = clazz;
 53:                                             } else if (!cachedAdaptiveClass.equals(clazz)) {
 54:                                                 throw new IllegalStateException(&quot;More than 1 adaptive class found: &quot;
 55:                                                         + cachedAdaptiveClass.getClass().getName()
 56:                                                         + &quot;, &quot; + clazz.getClass().getName());
 57:                                             }
 58:                                         } else {
 59:                                             // 缓存拓展 Wrapper 实现类到 `cachedWrapperClasses`
 60:                                             try {
 61:                                                 clazz.getConstructor(type);
 62:                                                 Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;
 63:                                                 if (wrappers == null) {
 64:                                                     cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();
 65:                                                     wrappers = cachedWrapperClasses;
 66:                                                 }
 67:                                                 wrappers.add(clazz);
 68:                                             // 缓存拓展实现类到 `extensionClasses`
 69:                                             } catch (NoSuchMethodException e) {
 70:                                                 clazz.getConstructor();
 71:                                                 // 未配置拓展名，自动生成。例如，DemoFilter 为 demo 。主要用于兼容 Java SPI 的配置。
 72:                                                 if (name == null || name.length() == 0) {
 73:                                                     name = findAnnotationName(clazz);
 74:                                                     if (name == null || name.length() == 0) {
 75:                                                         if (clazz.getSimpleName().length() &gt; type.getSimpleName().length()
 76:                                                                 &amp;&amp; clazz.getSimpleName().endsWith(type.getSimpleName())) {
 77:                                                             name = clazz.getSimpleName().substring(0, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();
 78:                                                         } else {
 79:                                                             throw new IllegalStateException(&quot;No such extension name for the class &quot; + clazz.getName() + &quot; in the config &quot; + url);
 80:                                                         }
 81:                                                     }
 82:                                                 }
 83:                                                 // 获得拓展名，可以是数组，有多个拓展名。
 84:                                                 String[] names = NAME_SEPARATOR.split(name);
 85:                                                 if (names != null &amp;&amp; names.length &gt; 0) {
 86:                                                     // 缓存 @Activate 到 `cachedActivates` 。
 87:                                                     Activate activate = clazz.getAnnotation(Activate.class);
 88:                                                     if (activate != null) {
 89:                                                         cachedActivates.put(names[0], activate);
 90:                                                     }
 91:                                                     for (String n : names) {
 92:                                                         // 缓存到 `cachedNames`
 93:                                                         if (!cachedNames.containsKey(clazz)) {
 94:                                                             cachedNames.put(clazz, n);
 95:                                                         }
 96:                                                         // 缓存拓展实现类到 `extensionClasses`
 97:                                                         Class&lt;?&gt; c = extensionClasses.get(n);
 98:                                                         if (c == null) {
 99:                                                             extensionClasses.put(n, clazz);
100:                                                         } else if (c != clazz) {
101:                                                             throw new IllegalStateException(&quot;Duplicate extension &quot; + type.getName() + &quot; name &quot; + n + &quot; on &quot; + c.getName() + &quot; and &quot; + clazz.getName());
102:                                                         }
103:                                                     }
104:                                                 }
105:                                             }
106:                                         }
107:                                     }
108:                                 } catch (Throwable t) {
109:                                     // 发生异常，记录到异常集合
110:                                     IllegalStateException e = new IllegalStateException(&quot;Failed to load extension class(interface: &quot; + type + &quot;, class line: &quot; + line + &quot;) in &quot; + url + &quot;, cause: &quot; + t.getMessage(), t);
111:                                     exceptions.put(line, e);
112:                                 }
113:                             }
114:                         } // end of while read lines
115:                     } finally {
116:                         reader.close();
117:                     }
118:                 } catch (Throwable t) {
119:                     logger.error(&quot;Exception when load extension class(interface: &quot; +
120:                             type + &quot;, class file: &quot; + url + &quot;) in &quot; + url, t);
121:                 }
122:             } // end of while urls
123:         }
124:     } catch (Throwable t) {
125:         logger.error(&quot;Exception when load extension class(interface: &quot; +
126:                 type + &quot;, description file: &quot; + fileName + &quot;).&quot;, t);
127:     }
128: }</code></pre>
<ul>
<li><p>第 9 行：获得完整的文件名( 相对路径 )。例如：<code>&quot;META-INF/dubbo/internal/com.alibaba.dubbo.common.extension.ExtensionFactory&quot;</code> 。</p>
</li>
<li><p>第 12 至 18 行：获得文件名对应的所有文件 URL 数组。例如：<img src="/Users/ocean/Downloads/04.png" alt="ExtensionFactory 的配置文件"></p>
</li>
<li><p>第 21 至 24 行：逐个<strong>文件</strong> URL 遍历。</p>
</li>
<li><p>第 27 行：逐<strong>行</strong>遍历。</p>
</li>
<li><p>第 29 至 32 行：跳过当前被 <code>&quot;#&quot;</code> 注释掉的情况，例如 <code>#spring=xxxxxxxxx</code> 。</p>
</li>
<li><p>第 34 至 40 行：按照 <code>key=value</code> 的配置拆分。其中 <code>name</code> 为拓展名，<code>line</code> 为拓展实现类名。<strong>注意</strong>，上文我们提到过 Dubbo SPI 会兼容 Java SPI 的配置格式，那么按照此处的解析方式，<code>name</code> 会为空。这种情况下，拓展名会自动生成，详细见第 71 至 82 行的代码。</p>
</li>
<li><p>第 42 至 48 行：判断拓展实现类，需要实现拓展接口。</p>
</li>
<li><p>第 50 至 57 行：缓存自适应拓展对象的类到 <code>cachedAdaptiveClass</code> 属性。在 <a href="http://svip.iocoder.cn/Dubbo/spi/#" target="_blank" rel="noopener">「6. @Adaptive」</a> 详细解析。</p>
</li>
<li><p>第 59 至 67 行：缓存拓展 Wrapper 实现类到 <code>cachedWrapperClasses</code> 属性。</p>
<ul>
<li><p>第 61 行：调用 <code>Class#getConstructor(Class... parameterTypes)</code> 方法，通过<strong>反射</strong>的方式，参数为拓展接口，判断当前配置的拓展实现类为<strong>拓展 Wrapper 实现类</strong>。若成功（未抛出异常），则代表符合条件。例如，<a href="https://github.com/alibaba/dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper.java#L39-L44" target="_blank" rel="noopener">ProtocolFilterWrapper(Protocol protocol)</a> 这个构造方法。</p>
<ul>
<li><pre><code class="java">public ProtocolFilterWrapper(Protocol protocol) {
        if (protocol == null) {
            throw new IllegalArgumentException(&quot;protocol == null&quot;);
        }
        this.protocol = protocol;
    }</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第 69 至 105 行：若获得构造方法失败，则代表是普通的拓展实现类，缓存到 <code>extensionClasses</code> <strong>变量</strong>中。</p>
<ul>
<li>第 70 行：调用 <code>Class#getConstructor(Class... parameterTypes)</code> 方法，获得参数为空的构造方法。</li>
<li>第 72 至 82 行：未配置拓展名，自动生成。<strong>适用于 Java SPI 的配置方式</strong>。例如，xxx.yyy.DemoFilter 生成的拓展名为 <code>demo</code> 。<ul>
<li>第 73 行：通过 <code>@Extension</code> 注解的方式设置拓展名的方式已经<strong>废弃</strong>，胖友可以无视该方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>第 84 行：获得拓展名。使用逗号进行分割，即多个拓展名可以对应同一个拓展实现类。</p>
</li>
<li><p>第 86 至 90 行：缓存 <code>@Activate</code> 到 <code>cachedActivates</code> 。在 <a href="http://svip.iocoder.cn/Dubbo/spi/#" target="_blank" rel="noopener">「7. @Activate」</a> 详细解析。</p>
</li>
<li><p>第 93 至 95 行：缓存到 <code>cachedNames</code> 属性。</p>
</li>
<li><p>第 96 至 102 行：缓存拓展实现类到 <code>extensionClasses</code> 变量。<strong>注意</strong>，相同拓展名，不能对应多个不同的拓展实现(SPI名字的扩展名只能有一个)。</p>
</li>
<li><p>第 108 至 112 行：若发生异常，记录到异常集合 <code>exceptions</code> 属性。</p>
</li>
</ul>
<h4 id="4-2-4-其他方法"><a href="#4-2-4-其他方法" class="headerlink" title="4.2.4 其他方法"></a>4.2.4 其他方法</h4><p>如下方法，和该流程无关，胖友可自行查看。</p>
<ul>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L537-L546" target="_blank" rel="noopener"><code>#getExtensionClass(name)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L459-L482" target="_blank" rel="noopener"><code>#findException(name)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L129-L131" target="_blank" rel="noopener"><code>#getExtensionName(extensionInstance)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L133-L135" target="_blank" rel="noopener"><code>#getExtensionName(extensionClass)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L277-L286" target="_blank" rel="noopener"><code>#getSupportedExtensions()</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L344-L350" target="_blank" rel="noopener"><code>#getDefaultExtensionName()</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L337" target="_blank" rel="noopener"><code>#hasExtension(name)</code></a></li>
</ul>
<h3 id="4-3-获得拓展加载器"><a href="#4-3-获得拓展加载器" class="headerlink" title="4.3 获得拓展加载器"></a>4.3 获得拓展加载器</h3><p>在 Dubbo 的代码里，常常能看到如下的代码：</p>
<pre><code class="java">ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name)</code></pre>
<h4 id="4-3-1-getExtensionLoader"><a href="#4-3-1-getExtensionLoader" class="headerlink" title="4.3.1 getExtensionLoader"></a>4.3.1 getExtensionLoader</h4><p><code>#getExtensionLoader(Class&lt;T&gt; type)</code> <strong>静态</strong>方法，根据拓展点的接口，获得拓展加载器。代码如下：</p>
<pre><code class="java">/**
 * 拓展加载器集合
 *
 * key：拓展接口
 */
 // 【静态属性】
private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;(); 

  1: /**
  2:  * 根据拓展点的接口，获得拓展加载器
  3:  *
  4:  * @param type 接口
  5:  * @param &lt;T&gt; 泛型
  6:  * @return 加载器
  7:  */
  8: @SuppressWarnings(&quot;unchecked&quot;)
  9: public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) {
 10:     if (type == null)
 11:         throw new IllegalArgumentException(&quot;Extension type == null&quot;);
 12:     // 必须是接口
 13:     if (!type.isInterface()) {
 14:         throw new IllegalArgumentException(&quot;Extension type(&quot; + type + &quot;) is not interface!&quot;);
 15:     }
 16:     // 必须包含 @SPI 注解
 17:     if (!withExtensionAnnotation(type)) {
 18:         throw new IllegalArgumentException(&quot;Extension type(&quot; + type +
 19:                 &quot;) is not extension, because WITHOUT @&quot; + SPI.class.getSimpleName() + &quot; Annotation!&quot;);
 20:     }
 21: 
 22:     // 获得接口对应的拓展点加载器
 23:     ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
 24:     if (loader == null) {
 25:         EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));
 26:         loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
 27:     }
 28: }</code></pre>
<ul>
<li>第 12 至 15 行：必须是接口。</li>
<li>第 16 至 20 行：调用 <a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L101-L103" target="_blank" rel="noopener"><code>#withExtensionAnnotation()</code></a> 方法，校验必须使用 <code>@SPI</code> 注解标记。</li>
<li>第 22 至 27 行：从 <code>EXTENSION_LOADERS</code> <strong>静态</strong>中获取拓展接口对应的 ExtensionLoader 对象。若不存在，则创建 ExtensionLoader 对象，并添加到 <code>EXTENSION_LOADERS</code>。</li>
</ul>
<h4 id="4-3-2-构造方法"><a href="#4-3-2-构造方法" class="headerlink" title="4.3.2 构造方法"></a>4.3.2 构造方法</h4><p>构造方法，代码如下：</p>
<pre><code class="java">/**
 * 拓展接口。
 * 例如，Protocol
 */
private final Class&lt;?&gt; type;
/**
 * 对象工厂
 *
 * 用于调用 {@link #injectExtension(Object)} 方法，向拓展对象注入依赖属性。
 *
 * 例如，StubProxyFactoryWrapper 中有 `Protocol protocol` 属性。
 */
private final ExtensionFactory objectFactory;

  1: private ExtensionLoader(Class&lt;?&gt; type) {
  2:     this.type = type;
  3:     objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
  4: }</code></pre>
<p><code>objectFactory</code> 属性，对象工厂，<strong>功能上和 Spring IOC 一致</strong>。</p>
<ul>
<li>用于调用 <a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L510-L535" target="_blank" rel="noopener"><code>#injectExtension(instance)</code></a> 方法时，向创建的拓展注入其依赖的属性。例如，<a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-filter/dubbo-filter-cache/src/main/java/com/alibaba/dubbo/cache/filter/CacheFilter.java#L38" target="_blank" rel="noopener"><code>CacheFilter.cacheFactory</code></a> 属性。</li>
<li>第 3 行：当拓展接口非 ExtensionFactory 时( 如果不加这个判断，会是一个死循环 )，调用 <code>ExtensionLoader#getAdaptiveExtension()</code> 方法，获得 ExtensionFactory 拓展接口的<strong>自适应</strong>拓展实现对象。<strong>为什么呢</strong>？在 <a href="http://svip.iocoder.cn/Dubbo/spi/#" target="_blank" rel="noopener">「8. ExtensionFactory」</a> 详细解析。</li>
</ul>
<h3 id="4-4-获得指定拓展对象"><a href="#4-4-获得指定拓展对象" class="headerlink" title="4.4 获得指定拓展对象"></a>4.4 获得指定拓展对象</h3><p>在 Dubbo 的代码里，常常能看到如下的代码：</p>
<pre><code class="java">ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name)</code></pre>
<h4 id="4-4-1-getExtension"><a href="#4-4-1-getExtension" class="headerlink" title="4.4.1 getExtension"></a>4.4.1 getExtension</h4><pre><code class="java">/**
 * 缓存的拓展对象集合
 *
 * key：拓展名
 * value：拓展对象
 *
 * 例如，Protocol 拓展
 *          key：dubbo value：DubboProtocol
 *          key：injvm value：InjvmProtocol
 *
 * 通过 {@link #loadExtensionClasses} 加载
 */
private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();

  1: /**
  2:  * Find the extension with the given name. If the specified name is not found, then {@link IllegalStateException}
  3:  * will be thrown.
  4:  */
  5: /**
  6:  * 返回指定名字的扩展对象。如果指定名字的扩展不存在，则抛异常 {@link IllegalStateException}.
  7:  *
  8:  * @param name 拓展名
  9:  * @return 拓展对象
 10:  */
 11: @SuppressWarnings(&quot;unchecked&quot;)
 12: public T getExtension(String name) {
 13:     if (name == null || name.length() == 0)
 14:         throw new IllegalArgumentException(&quot;Extension name == null&quot;);
 15:     // 查找 默认的 拓展对象
 16:     if (&quot;true&quot;.equals(name)) {
 17:         return getDefaultExtension();
 18:     }
 19:     // 从 缓存中 获得对应的拓展对象
 20:     Holder&lt;Object&gt; holder = cachedInstances.get(name);
 21:     if (holder == null) {
 22:         cachedInstances.putIfAbsent(name, new Holder&lt;Object&gt;());
 23:         holder = cachedInstances.get(name);
 24:     }
 25:     Object instance = holder.get();
 26:     if (instance == null) {
 27:         synchronized (holder) {
 28:             instance = holder.get();
 29:             // 从 缓存中 未获取到，进行创建缓存对象。
 30:             if (instance == null) {
 31:                 instance = createExtension(name);
 32:                 // 设置创建对象到缓存中
 33:                 holder.set(instance);
 34:             }
 35:         }
 36:     }
 37:     return (T) instance;
 38: }</code></pre>
<ul>
<li>第 15 至 18 行：调用 <code>#getDefaultExtension()</code> 方法，查询<strong>默认的</strong>拓展对象。在该方法的实现代码中，简化代码为 <code>getExtension(cachedDefaultName);</code> 。</li>
<li>第 19 至 28 行：从缓存中，获得拓展对象。</li>
<li>第 29 至 31 行：当缓存不存在时，调用 <code>#createExtension(name)</code> 方法，创建拓展对象。</li>
<li>第 33 行：添加创建的拓展对象，到缓存中。</li>
</ul>
<h4 id="4-4-2-createExtension"><a href="#4-4-2-createExtension" class="headerlink" title="4.4.2 createExtension"></a>4.4.2 createExtension</h4><p><code>#createExtension(name)</code> 方法，创建拓展名的拓展对象，并缓存。代码如下：</p>
<pre><code class="java">/**
 * 拓展实现类集合
 *
 * key：拓展实现类
 * value：拓展对象。
 *
 * 例如，key 为 Class&lt;AccessLogFilter&gt;
 *      value 为 AccessLogFilter 对象
 */
private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();

  1: /**
  2:  * 创建拓展名的拓展对象，并缓存。
  3:  *
  4:  * @param name 拓展名
  5:  * @return 拓展对象
  6:  */
  7: @SuppressWarnings(&quot;unchecked&quot;)
  8: private T createExtension(String name) {
  9:     // 获得拓展名对应的拓展实现类
 10:     Class&lt;?&gt; clazz = getExtensionClasses().get(name);
 11:     if (clazz == null) {
 12:         throw findException(name); // 抛出异常
 13:     }
 14:     try {
 15:         // 从缓存中，获得拓展对象。
 16:         T instance = (T) EXTENSION_INSTANCES.get(clazz);
 17:         if (instance == null) {
 18:             // 当缓存不存在时，创建拓展对象，并添加到缓存中。
 19:             EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
 20:             instance = (T) EXTENSION_INSTANCES.get(clazz);
 21:         }
 22:         // 注入依赖的属性
 23:         injectExtension(instance);
 24:         // 创建 Wrapper 拓展对象
 25:         Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;
 26:         if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) {
 27:             for (Class&lt;?&gt; wrapperClass : wrapperClasses) {
 28:                 instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
 29:             }
 30:         }
 31:         return instance;
 32:     } catch (Throwable t) {
 33:         throw new IllegalStateException(&quot;Extension instance(name: &quot; + name + &quot;, class: &quot; +
 34:                 type + &quot;)  could not be instantiated: &quot; + t.getMessage(), t);
 35:     }
 36: }</code></pre>
<ul>
<li>第 9 至 13 行：获得拓展名对应的拓展实现类。若不存在，调用 <code>#findException(name)</code> 方法，抛出异常。</li>
<li>第 16 行：从缓存 <code>EXTENSION_INSTANCES</code> <strong>静态</strong>属性中，获得拓展对象。</li>
<li>第 17 至 21 行：当缓存不存在时，创建拓展对象，并添加到 <code>EXTENSION_INSTANCES</code> 中。因为 <code>#getExtension(name)</code> 方法中已经加 <code>synchronized</code> 修饰，所以此处不用同步。</li>
<li>第 23 行：调用 <code>#injectExtension(instance)</code> 方法，向创建的拓展注入其依赖的属性。</li>
<li>第 24 至 30 行：创建 Wrapper 拓展对象，将 <code>instance</code> <strong>包装在其中</strong>。在 <a href="http://dubbo.apache.org/zh-cn/docs/dev/SPI.html" target="_blank" rel="noopener">《Dubbo 开发指南 —— 扩展点加载》</a> 文章中，如此介绍 Wrapper 类：</li>
</ul>
<blockquote>
<p>Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 ExtensionLoader 返回扩展点时，包装在真正的扩展点实现外。即从 ExtensionLoader 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。</p>
<p>扩展点的 Wrapper 类可以有多个，也可以根据需要新增。</p>
<p>通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。</p>
</blockquote>
<h4 id="4-4-3-injectExtension"><a href="#4-4-3-injectExtension" class="headerlink" title="4.4.3 injectExtension"></a>4.4.3 injectExtension</h4><p><code>#injectExtension(instance)</code> 方法，注入依赖的属性。代码如下：</p>
<pre><code class="java">1: /**
 2:  * 注入依赖的属性
 3:  *
 4:  * @param instance 拓展对象
 5:  * @return 拓展对象
 6:  */
 7: private T injectExtension(T instance) {
 8:     try {
 9:         if (objectFactory != null) {
10:             for (Method method : instance.getClass().getMethods()) {
11:                 if (method.getName().startsWith(&quot;set&quot;)
12:                         &amp;&amp; method.getParameterTypes().length == 1
13:                         &amp;&amp; Modifier.isPublic(method.getModifiers())) { // setting &amp;&amp; public 方法
14:                     // 获得属性的类型
15:                     Class&lt;?&gt; pt = method.getParameterTypes()[0];
16:                     try {
17:                         // 获得属性
18:                         String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;;
19:                         // 获得属性值
20:                         Object object = objectFactory.getExtension(pt, property);
21:                         // 设置属性值
22:                         if (object != null) {
23:                             method.invoke(instance, object);
24:                         }
25:                     } catch (Exception e) {
26:                         logger.error(&quot;fail to inject via method &quot; + method.getName()
27:                                 + &quot; of interface &quot; + type.getName() + &quot;: &quot; + e.getMessage(), e);
28:                     }
29:                 }
30:             }
31:         }
32:     } catch (Exception e) {
33:         logger.error(e.getMessage(), e);
34:     }
35:     return instance;
36: }</code></pre>
<ul>
<li>第 9 行：必须有 <code>objectFactory</code> 属性，即 ExtensionFactory 的拓展对象，不需要注入依赖的属性。</li>
<li>第 10 至 13 行：反射获得所有的方法，仅仅处理 <code>public setting</code> 方法。</li>
<li>第 15 行：获得属性的类型。</li>
<li>第 18 行：获得属性名。</li>
<li>第 20 行：获得<strong>属性值</strong>。<strong>注意</strong>，此处虽然调用的是 <code>ExtensionFactory#getExtension(type, name)</code> 方法，实际获取的不仅仅是拓展对象，也可以是 Spring Bean 对象。答案在 <a href="http://svip.iocoder.cn/Dubbo/spi/#" target="_blank" rel="noopener">「8. ExtensionFactory」</a> 揭晓。</li>
<li>第 21 至 24 行：设置属性值。</li>
</ul>
<h4 id="4-4-4-其他方法"><a href="#4-4-4-其他方法" class="headerlink" title="4.4.4 其他方法"></a>4.4.4 其他方法</h4><p>如下方法，和该流程无关，胖友可自行查看。</p>
<ul>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L257-L275" target="_blank" rel="noopener"><code>#getLoadedExtension(name)</code></a></li>
<li><a href="https://github.com/YunaiV/dubbo/blob/6b8e51ac55880a0f10a34f297d0869fcdbb42369/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L277-L286" target="_blank" rel="noopener"><code>#getLoadedExtensions()</code></a></li>
</ul>
<h3 id="4-5-获得自适应的拓展对象"><a href="#4-5-获得自适应的拓展对象" class="headerlink" title="4.5 获得自适应的拓展对象"></a>4.5 获得自适应的拓展对象</h3><p>在 Dubbo 的代码里，常常能看到如下的代码：</p>
<pre><code class="java">ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()</code></pre>
<blockquote>
<p>友情提示，先看下 <a href="http://svip.iocoder.cn/Dubbo/spi/#" target="_blank" rel="noopener">「6. Adaptive」</a> 的内容，在回到此处。</p>
</blockquote>
<h4 id="4-5-1-getAdaptiveExtension"><a href="#4-5-1-getAdaptiveExtension" class="headerlink" title="4.5.1 getAdaptiveExtension"></a>4.5.1 getAdaptiveExtension</h4><p><code>#getAdaptiveExtension()</code> 方法，获得自适应拓展对象。</p>
<pre><code class="java">/**
 * 缓存的自适应( Adaptive )拓展对象
 */
private final Holder&lt;Object&gt; cachedAdaptiveInstance = new Holder&lt;Object&gt;();

/**
 * 创建 {@link #cachedAdaptiveInstance} 时发生的异常。
 *
 * 发生异常后，不再创建，参见 {@link #createAdaptiveExtension()}
 */
private volatile Throwable createAdaptiveInstanceError;

  1: /**
  2:  * 获得自适应拓展对象
  3:  *
  4:  * @return 拓展对象
  5:  */
  6: @SuppressWarnings(&quot;unchecked&quot;)
  7: public T getAdaptiveExtension() {
  8:     // 从缓存中，获得自适应拓展对象
  9:     Object instance = cachedAdaptiveInstance.get();
 10:     if (instance == null) {
 11:         // 若之前未创建报错，
 12:         if (createAdaptiveInstanceError == null) {
 13:             synchronized (cachedAdaptiveInstance) {
 14:                 instance = cachedAdaptiveInstance.get();
 15:                 if (instance == null) {
 16:                     try {
 17:                         // 创建自适应拓展对象
 18:                         instance = createAdaptiveExtension();
 19:                         // 设置到缓存
 20:                         cachedAdaptiveInstance.set(instance);
 21:                     } catch (Throwable t) {
 22:                         // 记录异常
 23:                         createAdaptiveInstanceError = t;
 24:                         throw new IllegalStateException(&quot;fail to create adaptive instance: &quot; + t.toString(), t);
 25:                     }
 26:                 }
 27:             }
 28:         // 若之前创建报错，则抛出异常 IllegalStateException
 29:         } else {
 30:             throw new IllegalStateException(&quot;fail to create adaptive instance: &quot; + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);
 31:         }
 32:     }
 33:     return (T) instance;
 34: }</code></pre>
<ul>
<li>第 9 行：从缓存 <code>cachedAdaptiveInstance</code> 属性中，获得自适应拓展对象。</li>
<li>第 28 至 30 行：若之前创建报错，则抛出异常 IllegalStateException 。</li>
<li>第 14 至 20 行：当缓存不存在时，调用 <code>#createAdaptiveExtension()</code> 方法，创建自适应拓展对象，并添加到 <code>cachedAdaptiveInstance</code> 中。</li>
<li>第 22 至 24 行：若创建发生异常，记录异常到 <code>createAdaptiveInstanceError</code> ，并抛出异常 IllegalStateException 。</li>
</ul>
<h4 id="4-5-2-createAdaptiveExtension"><a href="#4-5-2-createAdaptiveExtension" class="headerlink" title="4.5.2 createAdaptiveExtension"></a>4.5.2 createAdaptiveExtension</h4><p><code>#createAdaptiveExtension()</code> 方法，创建自适应拓展对象。代码如下：</p>
<pre><code class="java">/**
 * 创建自适应拓展对象
 *
 * @return 拓展对象
 */
@SuppressWarnings(&quot;unchecked&quot;)
private T createAdaptiveExtension() {
    try {
        return injectExtension((T) getAdaptiveExtensionClass().newInstance());
    } catch (Exception e) {
        throw new IllegalStateException(&quot;Can not create adaptive extension &quot; + type + &quot;, cause: &quot; + e.getMessage(), e);
    }
}</code></pre>
<ul>
<li>调用 <code>#getAdaptiveExtensionClass()</code> 方法，获得自适应拓展类。</li>
<li>调用 <code>Class#newInstance()</code> 方法，创建自适应拓展对象。</li>
<li>调用 <code>#injectExtension(instance)</code> 方法，向创建的自适应拓展对象，注入依赖的属性。</li>
</ul>
<h4 id="4-5-3-getAdaptiveExtensionClass"><a href="#4-5-3-getAdaptiveExtensionClass" class="headerlink" title="4.5.3 getAdaptiveExtensionClass"></a>4.5.3 getAdaptiveExtensionClass</h4><p><code>#getAdaptiveExtensionClass()</code> 方法，获得自适应拓展类。代码如下：</p>
<pre><code class="java">1: /**
 2:  * @return 自适应拓展类
 3:  */
 4: private Class&lt;?&gt; getAdaptiveExtensionClass() {
 5:     getExtensionClasses();
 6:     if (cachedAdaptiveClass != null) {
 7:         return cachedAdaptiveClass;
 8:     }
 9:     return cachedAdaptiveClass = createAdaptiveExtensionClass();
10: }</code></pre>
<ul>
<li>【<code>@Adaptive</code> 的第一种】第 6 至 8 行：若 <code>cachedAdaptiveClass</code> 已存在，直接返回。的第一种情况。</li>
<li>【<code>@Adaptive</code> 的第二种】第 9 行：调用 <code>#createAdaptiveExtensionClass()</code> 方法，<strong>自动生成</strong>自适应拓展的代码实现，并<strong>编译</strong>后返回该类。</li>
</ul>
<h4 id="4-5-4-createAdaptiveExtensionClassCode"><a href="#4-5-4-createAdaptiveExtensionClassCode" class="headerlink" title="4.5.4 createAdaptiveExtensionClassCode"></a>4.5.4 createAdaptiveExtensionClassCode</h4><p><code>#createAdaptiveExtensionClassCode()</code> 方法，自动生成自适应拓展的代码实现，并编译后返回该类。</p>
<pre><code class="java">1: /**
 2:  * 自动生成自适应拓展的代码实现，并编译后返回该类。
 3:  *
 4:  * @return 类
 5:  */
 6: private Class&lt;?&gt; createAdaptiveExtensionClass() {
 7:     // 自动生成自适应拓展的代码实现的字符串
 8:     String code = createAdaptiveExtensionClassCode();
 9:     // 编译代码，并返回该类
10:     ClassLoader classLoader = findClassLoader();
11:     com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();
12:     return compiler.compile(code, classLoader);
13: }</code></pre>
<p>第 8 行：调用 <a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L1012-L1253" target="_blank" rel="noopener"><code>#createAdaptiveExtensionClassCode</code></a> 方法，自动生成自适应拓展的代码实现的字符串。</p>
<ul>
<li><p>如下是 ProxyFactory 的自适应拓展的代码实现的字符串生成<strong>例子</strong></p>
<p><img src="/Users/ocean/Downloads/05.png" alt="自适应拓展的代码实现的字符串生成例子"></p>
</li>
<li><p>第 9 至 12 行：使用 Dubbo SPI 加载 Compier 拓展接口对应的拓展实现对象，后调用 <code>Compiler#compile(code, classLoader)</code> 方法，进行编译。</p>
</li>
</ul>
<h3 id="4-6-获得激活的拓展对象数组"><a href="#4-6-获得激活的拓展对象数组" class="headerlink" title="4.6 获得激活的拓展对象数组"></a>4.6 获得激活的拓展对象数组</h3><p>在 Dubbo 的代码里，看到使用代码如下：</p>
<pre><code class="java">List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</code></pre>
<h4 id="4-6-1-getExtensionLoader"><a href="#4-6-1-getExtensionLoader" class="headerlink" title="4.6.1 getExtensionLoader"></a>4.6.1 getExtensionLoader</h4><p><code>#getExtensionLoader(url, key, group)</code> 方法，获得符合自动激活条件的拓展对象数组。</p>
<pre><code class="java">1: /**
 2:  * This is equivalent to {@code getActivateExtension(url, url.getParameter(key).split(&quot;,&quot;), null)}
 3:  *
 4:  * 获得符合自动激活条件的拓展对象数组
 5:  *
 6:  * @param url   url
 7:  * @param key   url parameter key which used to get extension point names
 8:  *              Dubbo URL 参数名
 9:  * @param group group
10:  *              过滤分组名
11:  * @return extension list which are activated.
12:  * @see #getActivateExtension(com.alibaba.dubbo.common.URL, String[], String)
13:  */
14: public List&lt;T&gt; getActivateExtension(URL url, String key, String group) {
15:     // 从 Dubbo URL 获得参数值
16:     String value = url.getParameter(key);
17:     // 获得符合自动激活条件的拓展对象数组
18:     return getActivateExtension(url, value == null || value.length() == 0 ? null : Constants.COMMA_SPLIT_PATTERN.split(value), group);
19: }
20: 
21: /**
22:  * Get activate extensions.
23:  *
24:  * 获得符合自动激活条件的拓展对象数组
25:  *
26:  * @param url    url
27:  * @param values extension point names
28:  * @param group  group
29:  * @return extension list which are activated
30:  * @see com.alibaba.dubbo.common.extension.Activate
31:  */
32: public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) {
33:     List&lt;T&gt; exts = new ArrayList&lt;T&gt;();
34:     List&lt;String&gt; names = values == null ? new ArrayList&lt;String&gt;(0) : Arrays.asList(values);
35:     // 处理自动激活的拓展对象们
36:     // 判断不存在配置 `&quot;-name&quot;` 。例如，&lt;dubbo:service filter=&quot;-default&quot; /&gt; ，代表移除所有默认过滤器。
37:     if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {
38:         // 获得拓展实现类数组
39:         getExtensionClasses();
40:         // 循环
41:         for (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) {
42:             String name = entry.getKey();
43:             Activate activate = entry.getValue();
44:             if (isMatchGroup(group, activate.group())) { // 匹配分组
45:                 // 获得拓展对象
46:                 T ext = getExtension(name);
47:                 if (!names.contains(name) // 不包含在自定义配置里。如果包含，会在下面的代码处理。
48:                         &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name) // 判断是否配置移除。例如 &lt;dubbo:service filter=&quot;-monitor&quot; /&gt;，则 MonitorFilter 会被移除
49:                         &amp;&amp; isActive(activate, url)) { // 判断是否激活
50:                     exts.add(ext);
51:                 }
52:             }
53:         }
54:         // 排序
55:         Collections.sort(exts, ActivateComparator.COMPARATOR);
56:     }
57:     // 处理自定义配置的拓展对象们。例如在 &lt;dubbo:service filter=&quot;demo&quot; /&gt; ，代表需要加入 DemoFilter （这个是笔者自定义的）。
58:     List&lt;T&gt; usrs = new ArrayList&lt;T&gt;();
59:     for (int i = 0; i &lt; names.size(); i++) {
60:         String name = names.get(i);
61:         if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX) &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) { // 判断非移除的
62:             // 将配置的自定义在自动激活的拓展对象们前面。例如，&lt;dubbo:service filter=&quot;demo,default,demo2&quot; /&gt; ，则 DemoFilter 就会放在默认的过滤器前面。
63:             if (Constants.DEFAULT_KEY.equals(name)) {
64:                 if (!usrs.isEmpty()) {
65:                     exts.addAll(0, usrs);
66:                     usrs.clear();
67:                 }
68:             } else {
69:                 // 获得拓展对象
70:                 T ext = getExtension(name);
71:                 usrs.add(ext);
72:             }
73:         }
74:     }
75:     // 添加到结果集
76:     if (!usrs.isEmpty()) {
77:         exts.addAll(usrs);
78:     }
79:     return exts;
80: }</code></pre>
<ul>
<li>第 16 行：从 Dubbo URL 获得参数值。例如说，若 XML 配置 Service <code>&lt;dubbo:service filter=&quot;demo, demo2&quot; /&gt;</code> ，并且在获得 Filter 自动激活拓展时，此处就能解析到 <code>value=demo,demo2</code> 。另外，<code>value</code> 可以根据<strong>逗号</strong>拆分。</li>
<li>第 18 行：调用 <code>#getActivateExtension(url, values, group)</code> 方法，获得符合自动激活条件的拓展对象数组。</li>
<li>第 35 至 56 行：处理自动激活的拓展对象们。<ul>
<li><a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L357-L378" target="_blank" rel="noopener"><code>#isMatchGroup(group, groups)</code></a> 方法，匹配分组。</li>
<li><a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/ExtensionLoader.java#L380-L403" target="_blank" rel="noopener"><code>#isActive(Activate, url)</code></a> 方法，是否激活，通过 Dubbo URL 中是否存在参数名为 [<code>@Activate.value](mailto:</code>@Activate.value)` ，并且参数值非空。</li>
</ul>
</li>
<li>第 57 至 74 行：处理自定义配置的拓展对象们。</li>
<li>第 75 至 78 行：将 <code>usrs</code> 合并到 <code>exts</code> <strong>尾部</strong>。</li>
</ul>
<h3 id="4-6-2-ActivateComparator"><a href="#4-6-2-ActivateComparator" class="headerlink" title="4.6.2 ActivateComparator"></a>4.6.2 ActivateComparator</h3><p><a href="https://github.com/YunaiV/dubbo/blob/4a877ee283af70c3f6a19c3b8b8e6918696540e6/dubbo-common/src/main/java/com/alibaba/dubbo/common/extension/support/ActivateComparator.java" target="_blank" rel="noopener"><code>com.alibaba.dubbo.common.extension.support.ActivateComparator</code></a> ，自动激活拓展对象排序器。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 729535228@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>dubboSPI详解</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">7.6k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="Ocean Bai">Ocean Bai</a></p>
    <p><span class="copy-title">发布时间:</span>2020-02-17, 14:41:31</p>
    <p><span class="copy-title">最后更新:</span>2020-02-17, 17:15:07</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/02/17/dubbo/dubboSPI/" title="dubboSPI详解">http://yoursite.com/2020/02/17/dubbo/dubboSPI/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>








    </div>
    <div class="copyright">
        <p class="footer-entry">©2019-2020 Ocean</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#动态代理','#SPI','#面试','#垃圾','#类加载器','#缓存','#算法','#反射','#设计模式','#工厂模式','#总结面试','#设计原则','#jdk','#线程池',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
